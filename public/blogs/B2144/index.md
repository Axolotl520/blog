# B2144 阿克曼（Ackermann）函数

## 题目描述

阿克曼（Ackermann）函数 $A(m,n)$ 中，$m, n$ 定义域是非负整数（$m \le 3$，$n \le 10$），函数值定义为：

$\mathit{A}(m,n)=n+1$；（$m=0$ 时）。

$\mathit{A}(m,n)=\mathit{A}(m-1,1)$；（$m>0$、$n=0$ 时）。

$\mathit{A}(m,n)=\mathit{A}(m-1,\mathit{A}(m,n-1))$；（$m,n>0$ 时）。

输入m和n，调用akm函数，输出计算结果，并统计函数执行了多少步。

### 函数接口定义：
```python
def akm(m,n):
    pass
```
定义一个函数akm，计算akm(m,n)的结果

### 裁判测试程序样例：
```python
# 在此处填写函数代码
step=0
m,n=map(int, input().split())
print("Reulst:",akm(m,n))
print("Steps:",step)
```

### 输入样例：
在这里给出一组输入。例如：

```python
3 5
```
### 输出样例：
在这里给出相应的输出。例如：

```python
Reulst: 253
Steps: 42438
```
# 题解
### 前置芝士（递归）
递归作为一种算法在程序设计语言中广泛应用， 基本含义是指函数、过程、子程序在运行过程序中直接或间接调用自身而产生的重入现象。——360百科

推荐一个讲递归比较清楚的[博客](https://www.cnblogs.com/Pushy/p/8455862.html)

我并不认为递归像最上面说的那样麻烦，我认为递归就只是递归边界和函数调用的事罢了。

### 举个栗子：

```python
def fibonacci5(n):
   def fn(i):
       if i < 2:
           return 1
       else:
           return fn(i - 2) + fn(i - 1)
   for i in range(n):
       print(fn(i))
```
        

上面的函数，是求斐波那契数列的代码。

通过这个栗子，我们可以看出，递归边界是为了在特定情况下，防止函数再递归调用下去。上面，如果没有递归边界，这个函数就会继续调用，产生 $fib(0)，fib(−1)$ 等等奇怪的情况。而这一个递归边界，就是在函数无法再递归下去的时候（如果 $x<3，x−1$ 和 $x−2$ 其中一定会至少有一项 $<1$，也就是不合法）终止递归，返回斐波那契数列的第一项或第二项——$1$。

递归调用函数则是核心，每一个答案都是从其他的答案推导过来的。

如果我们往这个函数里传入一个参数 $5$，这个函数会发生像这样的事情：

$fib(5)$

$=fib(4)+fib(3)$

$=(fib(3)+fib(2))+(fib(2)+fib(1))$

$=((fib(2)+fib(1))+1)+(1+1)$

$=((1+1)+1)+2$

$=5$

每一项都是由前两项推导而成，这就是递归的一种简单的使用方法。

### 思路
这道题已经给你了所有的递归边界和递归调用方法，你只要把它转换成代码的形式，你就成功了！

### 代码
```python
def akm(m,n):
    global step
    step += 1
    if m == 0:
        return n+1
    elif m > 0 and n == 0:
        return akm(m-1,1)
    elif m > 0 and n > 0:
        return akm(m-1, akm(m,n-1))
step=0
m,n=map(int, input().split())
print("Reulst:",akm(m,n))
print("Steps:",step)
```
要注意的是，在引用$step$变量的时候要加上$global$关键字，否则会报错。

Ackermann 函数主要用于理论计算机科学中，研究递归函数的性质和复杂性。由于其增长速度极快，实际应用中通常限制输入范围。例如，m 和 n 的值通常限制在较小范围内（如 $ ≤ 3$ 和 $n ≤ 10$）。

需要注意的是，Ackermann 函数的计算可能会导致内存不足或程序卡死，因此在实现时需谨慎处理递归深度和资源消耗。